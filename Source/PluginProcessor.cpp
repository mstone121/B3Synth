/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
B3synthAudioProcessor::B3synthAudioProcessor()
{
	Wavetable wavetables[NUM_OF_TABLES];
	updateWavetables();
}

B3synthAudioProcessor::~B3synthAudioProcessor()
{
}

#pragma region Config

//==============================================================================
const String B3synthAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String B3synthAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String B3synthAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool B3synthAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool B3synthAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool B3synthAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool B3synthAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool B3synthAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double B3synthAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int B3synthAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int B3synthAudioProcessor::getCurrentProgram()
{
    return 0;
}

void B3synthAudioProcessor::setCurrentProgram (int index)
{
}

const String B3synthAudioProcessor::getProgramName (int index)
{
    return String();
}

void B3synthAudioProcessor::changeProgramName (int index, const String& newName)
{
}

#pragma endregion

//==============================================================================
void B3synthAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
	updateWavetables();
}

void B3synthAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void B3synthAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)	
{
	// Clear channels
	if (voices.empty())
	{
		for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
			buffer.clear(i, 0, buffer.getNumSamples());
	}
	// Write Channels
	else
	{		
		for (std::list<Voice>::iterator it = voices.begin(); it != voices.end();)
		{
			if ((*it).volume <= 0) {
				it = voices.erase(it);
			}
			else {

				for (int sample = 0; sample < buffer.getNumSamples(); ++sample)
				{
					float value = (*it).getNextSample();
					for (int channel = 0; channel < getNumInputChannels(); ++channel)
						buffer.getWritePointer(channel)[sample] += value * .5;

				}
				++it;
			}
		}
	}

	// Process Midi
	if (!midiMessages.isEmpty())
	{
		MidiBuffer::Iterator iterator(midiMessages);
		MidiMessage message;
		int samplePosition;

		while (iterator.getNextEvent(message, samplePosition))
			processMidiMessage(message);

	}
}

void B3synthAudioProcessor::processMidiMessage(MidiMessage &message)
{
	if (message.isNoteOnOrOff())
	{
		uint8 velocity = message.getVelocity();
		uint8 note = message.getNoteNumber();
		if (velocity == 0 || message.isNoteOff())
		{
			for (std::list<Voice>::iterator it = voices.begin(); it != voices.end(); ++it)
				if ((*it).note == note)
					(*it).offing = true;

		}
		else
		{
			for (std::list<Voice>::iterator it = voices.begin(); it != voices.end(); ++it)
				if ((*it).note == note) {
					(*it).offing = false;
					(*it).volume = 1;
					return;
				}

			voices.push_back(Voice(note, &wavetables[note % NUM_OF_TABLES]));
		}
	}		
}

//==============================================================================
bool B3synthAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* B3synthAudioProcessor::createEditor()
{
    return new B3synthAudioProcessorEditor (*this);
}

//==============================================================================
void B3synthAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void B3synthAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new B3synthAudioProcessor();
}

//====================== Other Functions =======================================
void B3synthAudioProcessor::updateWavetables() {
	double sample_rate;
	if (getSampleRate() == 0)
		sample_rate = 48000;
	else
		sample_rate = getSampleRate();

	for (int i = 0; i < NUM_OF_TABLES; ++i)
		wavetables[i].checkTable(MidiMessage::getMidiNoteInHertz(i), sample_rate, drawbar_values);

}
